#!/usr/bin/perl
#
# SNMPTTCONVERTMIB v1.5
#
# Copyright 2002-2022 Alex Burger
# alex_b@users.sourceforge.net
#
# 8/14/2002
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
##############################################################################
#
# http://www.sourceforge.net/projects/snmptt
#
###############################################################################
use strict;
use warnings;

#
# OPTIONS START
#
# Set this to '' to have no default EXEC line added, or modify as needed.
# Can also set on the command line with --exec='string'
my $defaultexec = '';

# Set this to '' to have no default EXEC line added, or modify as needed.
# Can also set on the command line with --exec='string'
my $defaultpreexec = '';

# Choose what type of quotes (if any) you want around the SUMMARY text pulled from the MIB.
#$defaultexecquote = '';		# no quotes
#$defaultexecquote = "\'";		# single (') quotes
my $defaultexecquote = "\"";		# double (") quotes

# Set this to 1 to have the --TYPE string prepended to the --SUMMARY string.
# Set to 0 to disable
my $prepend_type = 1;

#
# OPTIONS END
#
#############################################################################
#

my $snmpttconvertmib_version = "v1.5";

sub showversion
{
  print "\nSNMPTTCONVERTMIB $snmpttconvertmib_version\n";
  print "(c) 2002-2025 Alex Burger\n";
  print "http://snmptt.sourceforge.net\n\n";
}

##############################################################################
# Process command line arguments

$| = 1;

use Getopt::Long;
use File::Basename;
use File::Spec;

my $DEBUGGING = 0;

my $version = 0;
my $debug = 0;
my $help = 0;
my $net_snmp_perl = 0;
my $in = '';
my $out = '';
my $overwrite = 0;
my $nodes = '';
my $no_description = 0;
my $no_variables = 0;
my $no_format_summary = 0;
my $no_format_desc = 0;
my $format = 0;
my $format_desc = 0;
my $no_desc_wildcard = 0;
my $no_severity = 0;
my $severity = 'Normal';
my $exec = '';
my $exec_mode = 0;
my $exec_file = '';
my $preexec = '';
my $preexec_file = '';

my @exec_array = ();
my @preexec_array = ();

GetOptions 	('version' => \$version,
		'debug:i' => \$debug,
		'help' => \$help,
		'in=s' => \$in,
		'out=s' => \$out,
    'overwrite' => \$overwrite,
		'net_snmp_perl' => \$net_snmp_perl,
		'nodes=s' => \$nodes,
		'no_description' => \$no_description,
		'no_variables' => \$no_variables,
		'no_format_summary' => \$no_format_summary,
		'no_format_desc' => \$no_format_desc,
		'no_severity' => \$no_severity,
		'severity=s' => \$severity,
		'format=n' => \$format,
		'format_desc=n' => \$format_desc,
		'no_desc_wildcard' => \$no_desc_wildcard,
		'exec_mode=n' => \$exec_mode,
		'exec_file=s' => \$exec_file,
		'exec=s' => \$exec,
		'preexec_file=s' => \$preexec_file,
		'preexec=s' => \$preexec);

if ($version == 1)
{
  &showversion;
  exit(0);
}

if ($help == 1)
{
  &show_help();
  exit(0);
}

# Replace any spaces with -'s in severity
$severity =~ s/ /-/g;

if ($debug == 1)
{
  $DEBUGGING = 1;
}
if ($debug == 2)
{
  $DEBUGGING = 2;
}

if (($in eq "") || ($out eq ""))
{
  print "\n**** Missing arguments! ****\n";
  &show_help();
  exit 1;
}

if (($exec ne "") && ($exec_file ne ""))
{
  print "\n**** Please specify either --exec or --exec_file, not both. ****\n";
  &show_help();
  exit 1;
}
if (($preexec ne "") && ($preexec_file ne ""))
{
  print "\n**** Please specify either --preexec or --preexec_file, not both. ****\n";
  &show_help();
  exit 1;
}

# Get complete path of input file (MIB) in a portable way (needed for -m switch for snmptranslate)
my $dirname = dirname $in;
my $basename = basename $in;
my $input = File::Spec->catfile($dirname, $basename);

# Get complete path of output file (.conf) in a portable way 
$dirname = dirname $out;
$basename = basename $out;
my $output = File::Spec->catfile($dirname, $basename);

if (($exec eq "") && ($exec_file eq "")) {
  push(@exec_array, $defaultexec);
}
if (($preexec eq "") && ($preexec_file eq "")) {
  push(@preexec_array, $defaultpreexec);
}

if ($exec ne '')
{
  #$defaultexec = $exec;
  push(@exec_array, $exec);
  print "exec: $exec\n";
}
if ($preexec ne '')
{
  push(@preexec_array, $preexec);
  print "preexec: $preexec\n";
}

#print "nodes: $nodes\n";

if ($net_snmp_perl == 1)
{  
  print "\n\n*****  UCD-SNMP / NET-SNMP Perl module enabled *****\n\n";
}

print "\n\n*****  Processing MIB file *****\n\n";
my $snmptranslate_use_On;
check_snmptranslate_version();


print "severity: $severity\n";
print "\nFile to load is:        $input\n";
if ($overwrite == 1)
{
  print "File to OVERWRITE:      $output\n";
}
else
{
  print "File to APPEND TO:      $output\n";
}
if ($exec) {
  print "Exec argument:          $exec\n";
}
if ($exec_file) {
  print "Exec file:              $exec_file\n";
}
if ($preexec) {
  print "PreExec argument:       $preexec\n";
}
if ($preexec_file) {
  print "PreExec file:           $preexec_file\n";
}

# Set MIBS environment variable to the filename of the MIB file (not the mib name - if a file contains
# multiple MIB definitions in one file, the mib name will not work - at least with 5.0.8 and older)
$ENV{MIBS} = $input;
print "\nMIBS environment var:   $ENV{MIBS}\n";

###################################
# Load input file
if ($DEBUGGING >= 1)
{
  print "\nLoading $input\n";
}

my $fh_INPUTFILE;
unless (open $fh_INPUTFILE, "<", $input)
{
  die "Cannot open input file: $!";
}

my @mibfile;

while (<$fh_INPUTFILE>)
{
  chomp;			# remove <cr> at end of line
  s/\015//;			# Remove any DOS carriage returns
  push(@mibfile, $_);		# add to each line to @trapconf array
}
close $fh_INPUTFILE;

if ($DEBUGGING >= 1)
{
  print "Finished loading $input\n\n";
}

###################################
# Load exec_file
if ($exec_file) {
  if ($DEBUGGING >= 1)
  {
    print "\nLoading $exec_file\n";
  }

  my $fh_EXECFILE;
  unless (open $fh_EXECFILE, "<", $exec_file)
  {
    die "Cannot open input file: $!";
  }

  while (<$fh_EXECFILE>)
  {
    chomp;			# remove <cr> at end of line
    s/\015//;			# Remove any DOS carriage returns
    push(@exec_array, $_);		# add to each line to @trapconf array
  }
  close $fh_EXECFILE;

  if ($DEBUGGING >= 1)
  {
    print "Finished loading $exec_file\n\n";
  }
}

my $currentline=0;

if ($exec_array[0] ne "") {
  print "Exec(s):              \n";
  foreach my $temp (@exec_array) {
    print "  $temp\n";
  }
}

###################################
# Load preexec_file
if ($preexec_file) {
  if ($DEBUGGING >= 1)
  {
    print "\nLoading $preexec_file\n";
  }

  my $fh_PREEXECFILE;
  unless (open $fh_PREEXECFILE, "<", $preexec_file)
  {
    die "Cannot open input file: $!";
  }

  while (<$fh_PREEXECFILE>)
  {
    chomp;			# remove <cr> at end of line
    s/\015//;			# Remove any DOS carriage returns
    push(@preexec_array, $_);		# add to each line to @trapconf array
  }
  close $fh_PREEXECFILE;

  if ($DEBUGGING >= 1)
  {
    print "Finished loading $preexec_file\n\n";
  }
}

$currentline=0;

if ($preexec_array[0] ne "") {
  print "PreExec(s):              \n";
  foreach my $temp (@preexec_array) {
    print "  $temp\n";
  }
}

###################################
# Open output file
my $fh_OUTPUTFILE;
if ($overwrite == 0)
{
  # Append to the file
  unless (open $fh_OUTPUTFILE, ">>", $output)
  {
    die "Cannot open output file: $!";
  }
}
else
{
  # Overwrite the file
  unless (open $fh_OUTPUTFILE, ">", $output)
  {
    die "Cannot open output file: $!";
  }
}
###################################


# A mib file can contain multiple BEGIN definitions.  This finds the first one
# to make sure we have at least one definition.
# Determine name of MIB file
my $mib_name = '';
while ($currentline <= $#mibfile)
{
  my $line = $mibfile[$currentline];

  # Sometimes DEFINITIONS ::= BEGIN will appear on the line following the mib name.
  # Look for DEFINITIONS ::= BEGIN with nothing (white space allowed) around it and a previous line with 
  # only a single word with whitespace around it.
  if ($currentline > 0 && $line =~ /^\s*DEFINITIONS\s*::=\s*BEGIN\s*$/ && $mibfile[$currentline-1] =~ /^\s*(\S+)\s*$/) {
    # We should have found the mib name
    $mib_name = $1;
    print "\nSplit line DEFINITIONS ::= BEGIN found ($1).\n";
    $mib_name =~ s/\s+//g;
    last;
  }

  elsif ($line =~ /(.*)DEFINITIONS\s*::=\s*BEGIN/)
  {
    $mib_name = $1;
    $mib_name =~ s/\s+//g;
    last;
  }
  $currentline++;
}
print "MIB name:               $mib_name\n";
if ($mib_name eq '')
{
  print "\n\nAborting!!!\n";
  print "Could not find DEFINITIONS ::= BEGIN statement in MIB file!\n\n";
  exit (1);
}

if ($net_snmp_perl == 1)
{
  require SNMP;
  {
    no warnings;  # Variable is only used once
    $SNMP::save_descriptions = 1;	# Need them only for looking up variable descriptions. 
                                  # Do TRAP definition by hand to be able to pull out 
			                          	# the SUMMARY lines
  }
  &SNMP::initMib();
  
  print "\n\n*****  Using UCD-SNMP / NET-SNMP Perl module *****\n\n";
}

my $total_translations = 0;
my $successful_translations = 0;
my $failed_translations = 0;
$currentline=0;

#if ($net_snmp_perl == 0)
if (1)
{
  # Process the trap files by hand
  
  while ($currentline <= $#mibfile)
  {
    my $line = $mibfile[$currentline];

    # Sometimes DEFINITIONS ::= BEGIN will appear on the line following the mib name.
    # Look for DEFINITIONS ::= BEGIN with nothing (white space allowed) around it and a previous line with 
    # only a single word with whitespace around it.
    if ($currentline > 0 && $line =~ /^\s*DEFINITIONS\s*::=\s*BEGIN\s*$/ && $mibfile[$currentline-1] =~ /^\s*(\S+)\s*$/) {
      # We should have found the mib name
      print "\n\nSplit line DEFINITIONS ::= BEGIN found ($1).\n";

      $mib_name = $1;
      $mib_name =~ s/\s+//g;
      print "Processing MIB:         $mib_name\n";
     
      print $fh_OUTPUTFILE "#\n#\n#\n#\n";
      print $fh_OUTPUTFILE "MIB: $mib_name (file:$input) converted on " . scalar(localtime) . " using snmpttconvertmib $snmpttconvertmib_version\n";
      
      $currentline++; # Increment to the next line
      next;
    }

    elsif ($line =~ /(.*)DEFINITIONS\s*::=\s*BEGIN/)
    {
      $mib_name = $1;
      $mib_name =~ s/\s+//g;
      print "\n\nProcessing MIB:         $mib_name\n";
     
      print $fh_OUTPUTFILE "#\n#\n#\n#\n";
      print $fh_OUTPUTFILE "MIB: $mib_name (file:$input) converted on " . scalar(localtime) . " using snmpttconvertmib $snmpttconvertmib_version\n";
      
      $currentline++; # Increment to the next line
      next;
    }

    # TRAP-TYPE (V1) / NOTIFICATION-TYPE (V2)
    #
    # eg: 'mngmtAgentTrap-23003 TRAP-TYPE';
    # eg: 'ciscoSystemClockChanged NOTIFICATION-TYPE';
    if ( $line =~ /(.*)\s*TRAP-TYPE.*/ || 
         $line =~ /(.*)\s*NOTIFICATION-TYPE.*/ )
    {
      # Line may be a TRAP-TYPE or NOTIFICATION-TYPE definition.

      my $trapname = $1;
      my $trapversion;

      if ( $line =~ /TRAP-TYPE/ )
      {
        $trapversion = 'TRAP';
      }
      else
      {
        $trapversion = 'NOTIFICATION';
      }

      my $enterprisefound = 0;
      
      my @variables = ();

      print "#\n";

      # If line follows the SMIv2/ASN.1 identifier rules
      if ($line =~ /^\s*([A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])\s+NOTIFICATION-TYPE\b/ ||
          $line =~ /^\s*([A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])\s+TRAP-TYPE\b/) {
        # ^\s*	                                  Match optional leading whitespace
        # ([A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])     Capture group: valid SMIv2 identifier (must start with a letter, can contain alphanumerics and hyphens, cannot end in a hyphen)
        # \s+NOTIFICATION-TYPE                    Require a space then the keyword
        # \b                                      Ensure it is a whole word (not part of another identifier) / Ensure the keyword ends cleanly
        $trapname = $1;
        print "SMIv2/ASN.1 valid TRAP/NOTIFICATION line detected for ($1).\n";
      }

      # Make sure it doesn't start with a --.  If it does, it's a comment line..  Skip it
      elsif ($line =~/.*--.*TRAP-TYPE/ || $line =~/.*--.*NOTIFICATION-TYPE/) {
        $currentline++; # Increment to the next line
        $line = $mibfile[$currentline]; # Get next line
        next;
      }

      # Sometimes the TRAP-TYPE / NOTIFICATION-TYPE will appear on the line following the trap name
      # Look for xxx-TYPE with nothing (white space allowed) around it and a previous line with only a single word
      # with whitespace around it.
      # This pattern is common in SMIv1 MIB modules, where the TRAP-TYPE macro is used. Here’s a canonical example drawn from RFC 1215:
      # Example:
      # myLinkDown
      #     TRAP-TYPE
      #         ENTERPRISE  myEnterprise
      #         VARIABLES   { ifIndex }
      #         DESCRIPTION
      #                "A myLinkDown trap signifies that the sending
      #                 SNMP application entity recognizes a failure
      #                 in one of the communications links represented
      #                 in the agent's configuration."
      #         ::= 2
      elsif ( ($currentline > 0 && $line =~ /^\s*TRAP-TYPE\s*$/ && $mibfile[$currentline-1] =~ /^\s*(\S+)\s*$/) ||
           ($currentline > 0 && $line =~ /^\s*NOTIFICATION-TYPE\s*$/ && $mibfile[$currentline-1] =~ /^\s*(\S+)\s*$/) ) {
        # We should have found the trap name
        $trapname = $1;
        print "Split line TRAP-TYPE / NOTIFICATION-TYPE found ($1).\n";
      }
      
      # If the last check didn't pass and the line starts with whitespace and then TRAP-TYPE / NOTIFICATION-TYPE, it's probably a import line, so ignore
      elsif ( $line =~ /^\s+TRAP-TYPE.*/ ||
           $line =~ /^\s+NOTIFICATION-TYPE.*/  ||
           $line =~ /^.*,.*NOTIFICATION-TYPE.*/ )
      {
        print "skipping a TRAP-TYPE / NOTIFICATION-TYPE line - probably an import line.\n";
        $currentline++; # Increment to the next line
        $line = $mibfile[$currentline]; # Get next line
        next;
      }

      # If the line does not match the TRAP-TYPE / NOTIFICATION-TYPE pattern, skip it
      else {
        print "Skipping a TRAP-TYPE / NOTIFICATION-TYPE on line $currentline as it does not match expected pattern.\n";
        $currentline++; # Increment to the next line
        $line = $mibfile[$currentline]; # Get next line
        next;
      }
      
      # Remove beginning and trailing white space
      $trapname =~ /\s*([A-Za-z0-9_-]+)\s*/;
      $trapname = $1;

      print "Line: $currentline\n";
      if ($trapversion eq 'TRAP')
      {
        print "TRAP-TYPE: $1\n";		# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      else
      {
        print "NOTIFICATION-TYPE: $1\n";	# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      
      $currentline++; # Increment to the next line
      my $line3 = $mibfile[$currentline];
      
      my $end_of_definition = 0;
      
      my $traptype = "";
      my $trapsummary = "";
      my @description = ();
      my $trap_severity = $severity;
      my $enterprise;
      my @arguments;
      my $formatexec;
      
      while ( ($currentline <= $#mibfile) && !($line3 =~ /\s+END\s+/) && !($line3 =~ /(.*)\s+TRAP-TYPE.*/ )
      && !($line3 =~ /(.*)\s+NOTIFICATION-TYPE.*/) && ($end_of_definition == 0) )
      {
        # Keep going through the file until the next TRAP-TYPE / NOTIFICATION-TYPE or the end of the mib file
        # is reached, or the end of the section (between BEGIN and END)
        
        # Look for DESCRIPTION and anything after (including newline with /s)
        # and capture that anything in $1
        
        # If line starts with ENTERPRISE, pull it out
        # Only applies to SNMPv1 TRAPs
        # (SNMPv2 NOTIFICATIONS have the enterprise in the ::= line)
	
        $traptype = "";
        $trapsummary = "";
        @description = ();
        $trap_severity = $severity;
	
        if ($line3 =~ /ENTERPRISE\s+(.*)/)
        {
          $enterprise = $1;
          $enterprisefound =1;
        }

        if ( ($line3 =~ /VARIABLES(.*)/s) || ($line3 =~ /OBJECTS(.*)/s) )
        {
          # If there is more text after the word VARIABLES or OBJECTS, assume it's the start of
          # the variable list
          my $templine = "";
          if ($1 ne "")
                {
                  $templine = $templine . $1;
                  $templine =~ s/--.*//; # Remove any trailing comments
          }

          if ($templine =~ /\}/)	# Contains a }, so we're done
          {
            # DONE!
          }
          else
          {
            $currentline++; # Increment to the next line
            my $line4 = $mibfile[$currentline];
                  $line4 =~ s/--.*//; # Remove any trailing comments
            my $keepdigging = 1;
            while (($currentline <= $#mibfile) && ($keepdigging == 1))
            {
                    $templine = $templine . $line4;
              if ($line4 =~ /\}/)	# Contains a }, so we're done
              {
                $keepdigging = 0;
              }
              else
              {
                $currentline++; # Increment to the next line
                $line4 = $mibfile[$currentline];
                $line4 =~ s/--.*//; # Remove any trailing comments
              }
            }
          }
          $templine =~ s/\s//g;	# Remove any white space
          $templine =~ /\{(.*)\}/; # Remove brackets
          @variables = split /\,/, $1;
          print "Variables: @variables\n";
        }
	
        if ($line3 =~ /DESCRIPTION(.*)/s)
        {
          my $temp1 = 0;

          # Start of DESCRIPTION
          
          #print "SDESC\n";
          
          # If there is more text after the word DESCRIPTION, assume it's the start of
          # the description.
          if ($1 ne "")
          {
            # Pull out text and remove beginning and trailing white space
            if ($1 =~ /\s*(.*)\s*/)
            {
              # Remove any quotes
              $_ = $1;
              s(\")()g;
              # "
              push (@description, "$_\n");
              
            }
          }
          
          $currentline++; # Increment to the next line
          my $line4 = $mibfile[$currentline];
          
          # Assume the rest is the description up until a ::= or end of the file
          while (! ($line4 =~ /::=/))
          {
            # If next line is a --#TYPE, pull out the information and place in $traptype
            if ($line4 =~ /--#TYPE(.*)/)
            {
              
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#TYPE\s*(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                $traptype = $_;
                #print "Type: $traptype \n";
              }
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            
            # If next line is a --#SUMMARY, pull out the information and place in $summary
            if ($line4 =~ /--#SUMMARY(.*)/)
            {
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#SUMMARY\s*(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                $trapsummary .= $_;
                #print "Summary: $trapsummary \n";
              }
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            # If next line is a --#ARGUMENTS, pull out the information and place in $arguments
            if ($line4 =~ /--#ARGUMENTS\s*{(.*)}/)
            {
              @arguments = split /,/, $1;

              for(my $i=0;$i <= $#arguments;$i++)
              {
                # Most ARGUMENTS lines have %n where n is a number starting 
                # at 0, but some MIBS have an ARGUMENTS line that have $1, $2,
                # etc and start at 1.  These need to have the $ removed and 
                # the number downshifted so the FORMAT will be generated 
                # properly.
                if ($arguments[$i] =~ /^\s*\$\d+/) {
                  $arguments[$i] =~ s/^\s*\$(\d+)/$1/;
                  $arguments[$i]--;
                }
                #print "argument $i: $arguments[$i]\n";
              }
              
              #for(my $i=0;$i <= $#arguments;$i++)
              #{
                #print "argument $i: $arguments[$i]\n";
              #}
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            # If next line is a --#SEVERITY, pull out the information and place in $trap_severity
            if ($line4 =~ /--#SEVERITY\s+(.*)/ && ! ($line4 =~ /--#SEVERITYMAP/))
            {
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#SEVERITY\s+(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                if ($no_severity == 0)
                {
                  $trap_severity = $_;
                }
                  #print "Severity: $trap_severity \n";
              }
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            # If next line starts with a --#, ignore it and continue with the loop
            # (we already got the SUMMARY line above)
            if ($line4 =~ /--#/)
            {
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            
            # If we did not find text after the word DESCRIPTION, then the NEXT
            # line must be the first line of description.
            
            # Remove beginning and trailing white space
            $line4 =~ (/\s*(.*)\s*/);
            if ($1 ne "")
            {
              # Remove any quotes
              $_ = $1;
              s(\")()g;
              # "
              
              push (@description, "$_\n");
              #print "c:$_\n";
            }
            
            $currentline++; # Increment to the next line
            $line4 = $mibfile[$currentline];
          }
          #print "EDESC\n";
          
          if ($line4 =~ /::=/)
          {
            $end_of_definition = 1;		# Move on to the next one
            
            if ($enterprisefound == 0)
            {
              # $line4 should now contain ::= line
              # # Pull out enterprise from { }
              # # Would only apply to SNMPv2 NOTIFICATIONS
              # #print "Line4: $line4\n";
              $line4 =~ /{(.*)\s\d.*/;
              
              #print "\$1=$1\n";
              $enterprisefound =1;
              
              # Remove any spaces
              $_ = $1;
              s( )()g;
              $enterprise = $_;
              print "Enterprise: $enterprise\n";
            }
          }
        }
        $currentline++; # Increment to the next line
        $line3 = $mibfile[$currentline];
      }
      
      # Combine Trap type and summary together to make new summary
      if ($traptype ne "" && $prepend_type == 1)
      {
        $trapsummary = $traptype . ": " . $trapsummary;
      }
      
      my $trap_lookup;
      if ($mib_name eq '')
      {
	      $trap_lookup = $trapname;
      }
      else
      {
	      $trap_lookup = "$mib_name\:\:$trapname";
      }
      print "Looking up via snmptranslate: $trap_lookup\n";
      
      my $trapoid;
      if ($snmptranslate_use_On == 1)
      {
	      $trapoid = `snmptranslate -IR -Ts -On $trap_lookup`;
      }
      else
      {
	      $trapoid = `snmptranslate -IR -Ts $trap_lookup`;
      }
      
      chomp $trapoid;
      if ($trapoid ne "")
      {
        print $fh_OUTPUTFILE "#\n#\n#\n";
        print $fh_OUTPUTFILE "EVENT $trapname $trapoid \"Status Events\" $trap_severity\n";
        
        # Loop through trapsummary and replace the %s and %d etc with %1 to %n
        
        #$j = $#arguments; # j is last element number
        #print "j is $j\n";
        
        # Change the %s or %d etc into $1 etc (starts at $1)
        $_ = $trapsummary;
        for (my $j=0; $j<= $#arguments; $j++)
        {
          my $variable = ($arguments[$j])+1;
          s(%[a-zA-Z])(\$$variable);
        }
        
        #print "new summary: $_\n";
        
        $trapsummary = $_;
        
        my $descriptionline1 = '';
        
        # Build description line for FORMAT / EXEC
        if ($format_desc == 0)		# First line of description
        {
          $descriptionline1 = $description[0];
          chomp ($descriptionline1);
        }
        else				# n sentence(s) of description
        {
          # Build single line copy of description
          my $description_temp;
          foreach my $a (@description)
          {
            my $b = $a;
            chomp($b);
            $description_temp = $description_temp . $b . " ";
          }
          chop $description_temp;
          
          # Split up based on sentences
          my @description_temp2 = split /\./, $description_temp;
          
          # Remove white space around each sentence and add a trailing .
          for (my $i=0 ; $i <= $#description_temp2; $i++)
          {
            $description_temp2[$i] =~ /\s*(.*)\s*/;
            $description_temp2[$i] = $1 . ".";
          }
          
          # Build description line based on the number of sentences requested.
          for (my $i=1 ; $i <= $format_desc; $i++)
          {
            if ($description_temp2[$i-1] ne '') {
              $descriptionline1 = $descriptionline1 . $description_temp2[$i-1] . " " ;
            }
          }
          chop $descriptionline1;	# Remove last space
        }
        
        if ($descriptionline1 ne "")
        {
          if ($descriptionline1 =~ /%[a-zA-Z]/)
          {
            # Sometimes the variables are in the first line of the description
            # Change the %s or %d etc into $1 etc (starts at $1)
            # There is no list of variables, so just put them in order starting at 1 and
            # going up to 20
            $_ = $descriptionline1;
            for (my $j=1; $j<= 20; $j++)
            {
              s(%[a-zA-Z])(\$$j);
            }
            $descriptionline1 = $_;
            #$descriptionlinehadvariables = 1;
          }
          else
          {
            if ($no_desc_wildcard == 0)
            {
              $descriptionline1 = "$descriptionline1 \$*";
            }
          }
        }
        
        $formatexec = '';
        
        if ($format == 0)	# --#SUMMARY or description
        {
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
          elsif ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
        }
        elsif ($format == 1)	# description or --#SUMMARY
        {
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
          elsif ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
        }
        elsif ($format == 2)	# --#SUMMARY and description
        {
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            if ($formatexec =~ /\.$/)	# If it already ends in a .
            {
              $formatexec = $formatexec . " " . $descriptionline1;
            }
            else
            {
              $formatexec = $formatexec . ". " . $descriptionline1;
            }
          }
        }
        elsif ($format == 3)	# description and --#SUMMARY
        {
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $formatexec . " " . $trapsummary;
          }
        }
        elsif ($format == 4)    # -- trap name and variables
        {
          $formatexec = "$trapname - ";
          for (my $i=1; $i < $#variables+2; $i++)
          {
            $formatexec .= "$variables[$i-1]:\$$i ";
          }
        }
        
        if ($formatexec ne '')
        {
          print $fh_OUTPUTFILE "FORMAT $formatexec\n";

          if ($preexec_array[0] ne "") {
            foreach my $preexec (@preexec_array) {
              if ($preexec eq "") {
                next;
              }
              print $fh_OUTPUTFILE "PREEXEC $preexec\n";
            }
          }

          if ($exec_array[0] ne "") {
            foreach my $exec (@exec_array) {
              if ($exec eq "") {
                next;
              }
              if ($exec_mode == 1){
                print $fh_OUTPUTFILE "EXEC $exec\n";
              }
              elsif ($exec_mode == 2){
                $_ = $exec;
                $exec = &substitute2 ("\$Fz", "$formatexec");
                print $fh_OUTPUTFILE "EXEC $exec\n";
              }
              else {
                print $fh_OUTPUTFILE "EXEC $exec $defaultexecquote$formatexec$defaultexecquote\n";
                #print "1:xxxxxxxxx\n";
              }
            }
          }
        }
        else
        {
          print $fh_OUTPUTFILE "FORMAT \$*\n";

          if ($preexec_array[0] ne "") {
            foreach my $preexec (@preexec_array) {
              if ($preexec eq "") {
                next;
              }
              print $fh_OUTPUTFILE "PREEXEC $preexec\n";
            }
          }

          if ($exec_array[0] ne "") {
            foreach my $exec (@exec_array) {
              if ($exec eq "") {
                next;
              }
              if ($exec_mode == 1){
                print $fh_OUTPUTFILE "EXEC $exec\n";
              }
              elsif ($exec_mode == 2){
                $_ = $exec;
                $exec = &substitute2 ("\$Fz", "$formatexec");
                print $fh_OUTPUTFILE "EXEC $exec\n";
              }
              else {
                print $fh_OUTPUTFILE "EXEC $exec $defaultexecquote\$*$defaultexecquote\n";
                #print "2:xxxxxxxxx\n";
              }
            }
          }
        }
        
        if ($nodes ne '')
        {
          print $fh_OUTPUTFILE "NODES $nodes\n";
        }
        
        if ($no_description == 0)
        {
          print $fh_OUTPUTFILE "SDESC\n";
          #print $fh_OUTPUTFILE "$descriptionline1\n";
          for (my $i=0; $i <= $#description; $i++)
          {
            print $fh_OUTPUTFILE "$description[$i]";
          }
	  
          # If net_snmp_perl is enabled, lookup each variable
          if (@variables && $no_variables == 0 && $net_snmp_perl == 1)
          {
            print $fh_OUTPUTFILE "Variables:\n";
            for (my $i=0; $i <= $#variables; $i++)
            {
              printf $fh_OUTPUTFILE "%3d: %s\n",$i+1,$variables[$i];
              printf $fh_OUTPUTFILE "     Syntax=\"" . $SNMP::MIB{$variables[$i]}{type} . "\"\n";
              if (uc $SNMP::MIB{$variables[$i]}{type} =~ /INTEGER/)
              {
                my $b = $SNMP::MIB{$variables[$i]}{enums};
                my %hash = %$b;
                my $i = 1;

                # Create a new copy of the hash swapping the key and the value
                my %temphash = ();
                while ((my $key, my $value) = each %hash)
                {
                  $temphash{$value} = $key;
                }
                # Print out the entries in the hash
                foreach my $c (sort keys %temphash)
                {
                  print $fh_OUTPUTFILE "       " . $c . ": $temphash{$c}\n";
                }
              }
              if ($SNMP::MIB{$variables[$i]}{description})
              {
                print $fh_OUTPUTFILE "     Descr=\"" . $SNMP::MIB{$variables[$i]}{description} . "\"\n";
              }
            }
          }
	  
        elsif (@variables ne "" && $no_variables == 0  && $net_snmp_perl == 0)
        {
          print $fh_OUTPUTFILE "Variables:\n";
          for (my $i=0; $i <= $#variables; $i++)
          {
            print $fh_OUTPUTFILE "  " . ($i+1) . ": " . $variables[$i] . "\n";
          }
        }
          print $fh_OUTPUTFILE "EDESC\n";
        }
        
        $currentline--;
      }
      
      print "OID: $trapoid\n";

      $total_translations++;
      if ($trapoid eq '')
      {
	      $failed_translations++;
      }
      else
      {
	      $successful_translations++;
      }
      
      #print "\@description is ", $#description,"\n";
      #print "going to next trap / notification\n\n";
    }
    
    $currentline++; # Increment to the next line
  }
  
  
  sub check_snmptranslate_version
  {
    $snmptranslate_use_On = 1;
    
    my $SNMPTRANSLATE;
    if (open $SNMPTRANSLATE, "-|", "snmptranslate -V 2>&1")
    {
      my $snmptranslatever = <$SNMPTRANSLATE>;
      close $SNMPTRANSLATE;
      
      chomp ($snmptranslatever);
      
      print "snmptranslate version: " . $snmptranslatever. "\n";
      
      if ($snmptranslatever =~ /UCD/i || $snmptranslatever =~ /NET-SNMP version: 5.0.1/i)
      {
        $snmptranslate_use_On = 0;
        if ($DEBUGGING >= 1)
        {
          print "snmptranslate is either UCD-SNMP, or NET-SNMP v5.0.1, so do not use the -On switch.  Version found: $snmptranslatever\n";
        }
      }
    }
  }
  # End of process the trap files by hand

  print "\n\nDone\n\n";
  print "Total translations:        $total_translations\n";
  print "Successful translations:   $successful_translations\n";
  print "Failed translations:       $failed_translations\n";

  if ($total_translations == 0) {
    print "\nThe MIB file did not contain any TRAP-TYPE or NOTIFICATION-TYPE definitions,\n";
    print "so no translations occured.  Try another MIB file.\n\n";
  }
}
close $fh_OUTPUTFILE;


# sub substitute2 (left, right)
#
# left:  inside of double quotes with escapes.  eg: "\$a"
# right: replacement string eg: $name, "hello", "hi$namebye"
#
# Only substitute if there is an odd number of $ or \ symbols before the 
# substitute variable (eg: a in $a).  If there is an even number (0,2,4 etc)
# then do NOT substitute.  If there is an odd number (1,3,5 etc) then
# substitute.  For example, if $a converted to x:
# $a      = x
# $$a     = $a
# $$$a    = $x
# $$$$a   = $$a
# $$$$$a  = $$x
# 
# We need variable length look behind pattern matching to do this, but Perl
# does not support it.  As an alternative we can reverse the string, do a
# substitute with look ahead, and reverse it back.
#
sub substitute2 {
  my $left = shift;
  my $right = shift;

  my $string_r = reverse $_;
  my $left_r = reverse $left;
  $left_r =~ s/\\/\\\\/g;               # escape \
  $left_r =~ s/\$/\\\$/g;               # escape $
  $left_r =~ s/\*/\\\*/g;               # escape *
  $left_r =~ s/\+/\\\+/g;               # escape +
  my $right_r = reverse $right;

  # The format is:
  # s/a\$((?=(\$\$)*(?!\$)))/b/g;
  # where 'a\$' is the reverse of what to look for and 'b' is what to replace 
  # it with (reversed).

  $string_r =~ s/$left_r((?=(\$\$)*(?!\$)))/$right_r/g;

  $_ = reverse $string_r;
}

sub show_help
{
  my $USAGE = qq/Usage:
  snmpttconvertmib --in= --out= [<options>]
Options:
  --debug=n              Set debug level (1 or 2)
  --help                 Display this message
  --version              Display author and version information
  --net_snmp_perl        Enable NET-SNMP Perl integration (see below)
  --in=filename          Input file
  --out=filename         Output file
  --overwrite            Overwrite the output file if it exists.
                         Default is to append to the file if it exists.
  --nodes=name or file   If specified, will insert a NODES line after FORMAT
                         or EXEC. The host name(s) separated by spaces, or
                         the name of the nodes file.  Use quotes for multiple
                         entries. See NODES section in readme.html for examples
  --no_description       Do not save the description
  --no_variables         Do not save the variable list in the description
  --no_format_summary    Do not use the --#SUMMARY lines for FORMAT \/ EXEC
  --no_format_desc       Do not use the description line for FORMAT \/ EXEC
  --no_severity          Do not use the --#SEVERITY line for EVENT line.  
                         Default severity of "Normal" will be used, unless 
                         --severity= is set
  --severity=s           Severity level for EVENT line.  Only used if there is 
                         no --#SEVERITY line, or --no_severity is set.  Must NOT 
                         contain any spaces.
                         Example: 
                           Critical
  --format=n             FORMAT \/ EXEC order preference
                           0 = --#SUMMARY or description (default)
                           1 = description or --#SUMMARY
                           2 = --#SUMMARY and description
                           3 = description and --#SUMMARY
                           4 = trap name and variables similar to FORMAT \$+\*
  --format_desc=n        How to convert the description line for FORMAT \/ EXEC
                           0 = First line of description (default)
                           n = n sentence(s) of description
  --no_desc_wildcard     To prevent \$* from being appended to the end of 
                         description text when used on the FORMAT \/ EXEC 
                         lines.  A wildcard is only used if the description 
                         line contained no variable definitions (\%n).
  --exec=command         Command line to use for EXEC line.  Use SINGLE quotes
                         with Unix.  The format string will be appended to the
                         end of the specified command, separated by a space.
                         See below for more information on --exec.
                         Example:
                           --exec='qpage -f TRAP notifygroup1'
  --exec_file=file       Same as --exec but pull text from a file instead of
                         specifying on the command line.  Useful for commands
                         that include quotes so that you don't have to worry
                         about escaping on the command line.
  --exec_mode            Sets the beheviour when the --exec option is used.
                         See EXEC notes below.
                         0 = append format line to the end (default)
                         1 = do not append format line to the end.  Useful if
                             you have added \$Fz to the --exec option which
                             will copy the converted FORMAT line in SNMPTT.
                         2 = Replace \$Fz in the --exec line with the format
                             line instead of appending to the end.
  --preexec=command      Command line to use for PREEXEC line.  Use SINGLE quotes
                         with Unix.  The format string will be appended to the
                         end of the specified command, separated by a space.
                         See below for more information on --exec.
  --preexec_file=file    Same as --preexec but pull text from a file instead of
                         specifying on the command line.  Useful for commands
                         that include quotes so that you don't have to worry
                         about escaping on the command line.
                  
  Note:  The only benefit in using the --net_snmp_perl switch (which requires
         the Net-SNMP Perl module to be installed) is that the Variables: 
         description section will include:
           -variable syntax
           -variable description
           -variable enums

        For example:
           2: globalStatus
              Syntax="INTEGER"
                2: ok
                4: failure
              Descr="Current status of the entire library system"

  Examples:

  snmpttconvertmib --in=\/usr\/share\/snmp\/mibs\/CPQHOST.mib \\
    --out=\/etc\/snmp\/snmptt.conf.compaqhost 

  snmpttconvertmib --in=\/usr\/share\/snmp\/mibs\/CPQHOST.mib \\
    --out=\/etc\/snmp\/snmptt.conf.compaqhost --exec 'qpage -f \\
    TRAP notifygroup1'

 snmpttconvertmib --in=\/usr\/share\/snmp\/mibs\/CPQHOST.mib \\
    --out=\/etc\/snmp\/snmptt.conf.compaqhost --exec 'myscript { \$Fz }'
 
/;
  
  &showversion;
  print $USAGE . "\n";
}
